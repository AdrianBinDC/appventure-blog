#+title: Match me if you can. Swift Pattern Matching in detail.
#+tags: swift ios cocoa
#+keywords: lisp swift optional scala simple optionals switch chaining
#+inactive: true
#+OPTIONS: toc:nil ^:{} 


Among the new features that Swift offers to Objective-C programmers is one that disguises itself like a boring old man while it offers huge potential for forming elegant solutions to otherwise unwieldy sets of nested branches. I'm of course talking about the =switch= statement that many Objective-C programmers probably consider as a clunky syntax device which is most entertaining when used as [[http://en.wikipedia.org/wiki/Duff's_device][Duff's Device]], yet usually offers little to no advantages over multiple if statements.

The =Switch= statement in Swift can do much more though. In the following tutorial, I will try to explain the various usages for these new features in more detail. I'll mostly ignore those solutions where there's no benefit over how =switch= works in Objective-C or C.

* Diving In
The main feature of =switch= is of course pattern matching, the ability to destructure values and match different switch cases based on correct match of the values to the cases. 

#+BEGIN_SRC Swift
// Example of the worst binary -> decimal converter in history
let bool1 = 1
let bool2 = 0
switch (bool1, bool2) {
   case (0, 0): print("0")
   case (0, 1): print("1")
   case (1, 0): print("2")
   case (1, 1): print("3")
}
#+END_SRC

For a short introduction into the tuple matching syntax above, have a look at my TUPLE BEST PRACTICES LINK

Pattern matching has long existed in other languages like Erlang, Scala, or Clojure. This is a boon, because it allows us to have a look at how those languages utilize pattern matching in order to solve their problems. We can even have a look at their examples to find the most practical ones that offer real world adaptability.

